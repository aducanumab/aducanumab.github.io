<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Final Interactive Map</title>
  <style>
    /* 웹페이지의 기본 여백을 없애고, 지도가 화면을 꽉 채우도록 설정합니다. */
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    /* Google 지도의 기본 정보창 여백(padding)을 제거합니다. */
    .gm-style-iw-c {
      padding: 0 !important;
    }
    .gm-style-iw-d {
      overflow: hidden !important; /* 스크롤바가 생기지 않도록 처리 */
    }

    /* 우리가 직접 만들 정보창 콘텐츠 스타일입니다. */
    .custom-infowindow-content {
      font-family: 'Nanum Gothic', sans-serif; /* 나눔고딕 폰트 적용 */
      font-size: 15px;                          /* 폰트 사이즈 15px */
      font-weight: bold;                        /* 폰트 굵게 (Bold) */
      padding: 12px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    /* 닫기 버튼 스타일입니다. */
    .custom-infowindow-content .close-button {
      margin-left: 15px;
      cursor: pointer;
      font-size: 18px;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&display=swap" rel="stylesheet">
</head>
<body>
  <div id="map"></div>

  <script>
    let map;
    // infoWindow 변수는 바깥에 선언만 해둡니다.
    let infoWindow;

    // 커스텀 닫기 버튼(X)을 클릭했을 때 이 함수가 호출됩니다.
    function closeInfoWindow() {
      if (infoWindow) {
        infoWindow.close();
      }
    }

    function initMap() {
      // --- ↓↓↓ infoWindow 객체 생성을 이 안으로 이동! ↓↓↓ ---
      // Google API가 로드된 것이 보장되는 이 시점에서 infoWindow 객체를 생성합니다.
      infoWindow = new google.maps.InfoWindow();
      // --- ↑↑↑ 여기까지 이동 --- ↑↑↑

      const mapCenter = { lat: 37.5665, lng: 126.9780 };
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: mapCenter,
      });
      loadAndProcessKml();
    }

    async function loadAndProcessKml() {
      const initialKmlUrl = 'https://raw.githubusercontent.com/aducanumab/aducanumab.github.io/refs/heads/main/map_data.kml';
      
      try {
        const initialResponse = await fetch(initialKmlUrl);
        if (!initialResponse.ok) throw new Error(`초기 KML 로딩 실패`);
        const initialKmlText = await initialResponse.text();
        const parser = new DOMParser();
        const initialKmlDoc = parser.parseFromString(initialKmlText, "application/xml");
        const kmlNs = 'http://www.opengis.net/kml/2.2';
        const hrefElem = initialKmlDoc.getElementsByTagNameNS(kmlNs, 'href')[0];
        if (!hrefElem) throw new Error('NetworkLink href를 찾을 수 없습니다.');
        
        const finalKmlUrl = hrefElem.textContent;

        const finalResponse = await fetch(finalKmlUrl);
        if (!finalResponse.ok) throw new Error(`최종 KML 로딩 실패`);
        const finalKmlText = await finalResponse.text();
        const finalKmlDoc = parser.parseFromString(finalKmlText, "application/xml");

        const styles = {};
        const styleElements = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Style');
        for (let i = 0; i < styleElements.length; i++) {
          const style = styleElements[i];
          const styleId = '#' + style.getAttribute('id');
          const lineStyle = style.getElementsByTagNameNS(kmlNs, 'LineStyle')[0];
          const polyStyle = style.getElementsByTagNameNS(kmlNs, 'PolyStyle')[0];
          styles[styleId] = {};
          if (lineStyle) {
            const lineColor = lineStyle.getElementsByTagNameNS(kmlNs, 'color')[0]?.textContent;
            const lineWidth = lineStyle.getElementsByTagNameNS(kmlNs, 'width')[0]?.textContent;
            if (lineColor) {
              const c = kmlColorToHex(lineColor);
              styles[styleId].strokeColor = c.color;
              styles[styleId].strokeOpacity = c.opacity;
            }
            if (lineWidth) styles[styleId].strokeWeight = parseFloat(lineWidth);
          }
          if (polyStyle) {
            const polyColor = polyStyle.getElementsByTagNameNS(kmlNs, 'color')[0]?.textContent;
            if (polyColor) {
              const c = kmlColorToHex(polyColor);
              styles[styleId].fillColor = c.color;
              styles[styleId].fillOpacity = c.opacity;
            }
          }
        }
        
        const placemarks = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Placemark');

        for (let i = 0; i < placemarks.length; i++) {
          const placemark = placemarks[i];
          const name = placemark.getElementsByTagNameNS(kmlNs, 'name')[0]?.textContent || '';
          const description = placemark.getElementsByTagNameNS(kmlNs, 'description')[0]?.textContent || '';
          const styleUrl = placemark.getElementsByTagNameNS(kmlNs, 'styleUrl')[0]?.textContent || '';
          const coordinatesElem = placemark.getElementsByTagNameNS(kmlNs, 'coordinates')[0];
          
          if (!coordinatesElem) continue;
          
          const coordinatesStr = coordinatesElem.textContent.trim();
          const path = coordinatesStr.split(/\s+/).map(coordStr => {
            const [lng, lat] = coordStr.split(',');
            if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
              return { lat: parseFloat(lat), lng: parseFloat(lng) };
            }
          }).filter(p => p);

          if (path.length === 0) continue;

          const polygonOptions = {
            paths: path,
            map: map,
            strokeColor: "#0000FF",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: "#0000FF",
            fillOpacity: 0.35
          };

          if (styles[styleUrl]) {
            Object.assign(polygonOptions, styles[styleUrl]);
          }
          
          const polygon = new google.maps.Polygon(polygonOptions);
          const center = getPolygonCenter(path);

          polygon.addListener('mouseover', () => {
            const contentString = `
              <div class="custom-infowindow-content">
                <span>${name}</span>
                <span class="close-button" onclick="closeInfoWindow()">×</span>
              </div>
            `;
            infoWindow.setContent(contentString);
            infoWindow.setPosition(center);
            infoWindow.open(map);
          });

          polygon.addListener('mouseout', () => {
            infoWindow.close();
          });
          
          const urlMatch = description.match(/https?:\/\/[^\s<]+/);
          if (urlMatch && urlMatch[0]) {
            polygon.addListener('click', () => {
              window.location.href = urlMatch[0];
            });
          }
        }
      } catch (error) {
        console.error('KML 처리 중 오류:', error);
        alert('지도 데이터를 처리하는 중 문제가 발생했습니다.');
      }
    }
    
    function getPolygonCenter(path) {
      const bounds = new google.maps.LatLngBounds();
      path.forEach(point => bounds.extend(point));
      return bounds.getCenter();
    }

    function kmlColorToHex(kmlColor) {
      const aabbggrr = kmlColor.padStart(8, '0');
      const alpha = parseInt(aabbggrr.substring(0, 2), 16) / 255.0;
      const blue = aabbggrr.substring(2, 4);
      const green = aabbggrr.substring(4, 6);
      const red = aabbggrr.substring(6, 8);
      return {
        color: `#${red}${green}${blue}`,
        opacity: alpha
      };
    }

    async function loadMap() {
      try {
        const response = await fetch('/.netlify/functions/get-api-key');
        const data = await response.json();
        const apiKey = data.apiKey;

        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap&loading=async`;
        script.async = true;
        document.head.appendChild(script);
      } catch (error) { // <-- 여기에 '{'가 추가되었습니다.
        console.error('API 키 로딩 실패:', error);
      }
    }

    loadMap();
  </script>
</body>
</html>
