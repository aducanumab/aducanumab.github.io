<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Final Interactive Map</title>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    let map;

    function initMap() {
      const mapCenter = { lat: 37.5665, lng: 126.9780 };
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: mapCenter,
      });
      loadAndProcessKml();
    }

    // KML 네트워크 링크를 따라가 최종 데이터를 파싱하는 함수
    async function loadAndProcessKml() {
      // 1. 첫 번째 KML 파일 (네트워크 링크만 있는 파일) 주소
      const initialKmlUrl = 'https://raw.githubusercontent.com/aducanumab/aducanumab.github.io/refs/heads/main/map_data.kml';
      
      try {
        // --- 1단계: '바로가기' 파일(첫 번째 KML) 불러오기 ---
        const initialResponse = await fetch(initialKmlUrl);
        if (!initialResponse.ok) throw new Error(`초기 KML 로딩 실패: ${initialResponse.statusText}`);
        const initialKmlText = await initialResponse.text();

        const parser = new DOMParser();
        const initialKmlDoc = parser.parseFromString(initialKmlText, "application/xml");

        // --- 2단계: 진짜 데이터의 URL 추출하기 ---
        const kmlNs = 'http://www.opengis.net/kml/2.2';
        const hrefElem = initialKmlDoc.getElementsByTagNameNS(kmlNs, 'href')[0];
        if (!hrefElem) throw new Error('KML 파일에서 NetworkLink href를 찾을 수 없습니다.');
        
        const finalKmlUrl = hrefElem.textContent; // 진짜 데이터가 있는 최종 URL

        // --- 3단계: 진짜 데이터(두 번째 KML) 불러오기 ---
        const finalResponse = await fetch(finalKmlUrl);
        if (!finalResponse.ok) throw new Error(`최종 KML 로딩 실패: ${finalResponse.statusText}`);
        const finalKmlText = await finalResponse.text();

        // --- 4단계: 최종 데이터를 파싱하여 폴리곤 생성 (이전과 동일) ---
        const finalKmlDoc = parser.parseFromString(finalKmlText, "application/xml");
        const placemarks = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Placemark');
        
        const infoWindow = new google.maps.InfoWindow();

        for (let i = 0; i < placemarks.length; i++) {
          const placemark = placemarks[i];
          const name = placemark.getElementsByTagNameNS(kmlNs, 'name')[0].textContent;
          const coordinatesElem = placemark.getElementsByTagNameNS(kmlNs, 'coordinates')[0];
          
          if (!coordinatesElem) continue;
          
          const coordinatesStr = coordinatesElem.textContent.trim();
          
          const path = coordinatesStr.split(/\s+/).map(coordStr => {
            const [lng, lat] = coordStr.split(',');
            if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
              return { lat: parseFloat(lat), lng: parseFloat(lng) };
            }
          }).filter(p => p);

          if (path.length === 0) continue;

          const polygon = new google.maps.Polygon({
            paths: path,
            strokeColor: "#FF0000",
            fillColor: "#FF0000",
            fillOpacity: 0.35,
            map: map
          });

          polygon.addListener('mouseover', (event) => {
            infoWindow.setContent(`<div>${name}</div>`);
            infoWindow.setPosition(event.latLng);
            infoWindow.open(map);
          });

          polygon.addListener('mouseout', () => {
            infoWindow.close();
          });
        }
      } catch (error) {
        console.error('KML 처리 중 오류:', error);
        alert('지도 데이터를 처리하는 중 문제가 발생했습니다.');
      }
    }

    // API 키를 안전하게 불러오는 함수 (이전과 동일)
    async function loadMap() {
      try {
        const response = await fetch('/.netlify/functions/get-api-key');
        const data = await response.json();
        const apiKey = data.apiKey;

        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap&loading=async`;
        script.async = true;
        document.head.appendChild(script);
      } catch (error) {
        console.error('API 키 로딩 실패:', error);
      }
    }

    loadMap();
  </script>
</body>
</html>
